// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cluster_comm.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type RaftState int32

const (
	RaftState_Nonvoter RaftState = 0
	RaftState_Voter    RaftState = 1
	RaftState_Leader   RaftState = 2
)

var RaftState_name = map[int32]string{
	0: "Nonvoter",
	1: "Voter",
	2: "Leader",
}
var RaftState_value = map[string]int32{
	"Nonvoter": 0,
	"Voter":    1,
	"Leader":   2,
}

func (x RaftState) String() string {
	return proto.EnumName(RaftState_name, int32(x))
}
func (RaftState) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type RaftServiceError int32

const (
	RaftServiceError_NoRaftError             RaftServiceError = 0
	RaftServiceError_NotLeaderRaftError      RaftServiceError = 1
	RaftServiceError_KeyDoesntExistRaftError RaftServiceError = 2
)

var RaftServiceError_name = map[int32]string{
	0: "NoRaftError",
	1: "NotLeaderRaftError",
	2: "KeyDoesntExistRaftError",
}
var RaftServiceError_value = map[string]int32{
	"NoRaftError":             0,
	"NotLeaderRaftError":      1,
	"KeyDoesntExistRaftError": 2,
}

func (x RaftServiceError) String() string {
	return proto.EnumName(RaftServiceError_name, int32(x))
}
func (RaftServiceError) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type MemberInfo struct {
	// the long node id is also used as serf and raft node id
	LongMemberId string `protobuf:"bytes,1,opt,name=longMemberId" json:"longMemberId,omitempty"`
	// contains hostname
	Host string `protobuf:"bytes,2,opt,name=host" json:"host,omitempty"`
	// the unique id of a node
	ShortMemberId int32 `protobuf:"varint,3,opt,name=shortMemberId" json:"shortMemberId,omitempty"`
	// the port on which the raft library operates
	RaftPort int32 `protobuf:"varint,4,opt,name=raftPort" json:"raftPort,omitempty"`
	// the port on which the grpc consensus protocol operates
	RaftServicePort int32 `protobuf:"varint,5,opt,name=raftServicePort" json:"raftServicePort,omitempty"`
	// the port on which the grid protocol operates
	GridPort int32 `protobuf:"varint,6,opt,name=gridPort" json:"gridPort,omitempty"`
	// the port on which serf operates
	SerfPort int32 `protobuf:"varint,7,opt,name=serfPort" json:"serfPort,omitempty"`
	// the state of a particular node
	RaftState RaftState `protobuf:"varint,8,opt,name=raftState,enum=pb.RaftState" json:"raftState,omitempty"`
	// copy of the serf tags
	Tags map[string]string `protobuf:"bytes,9,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *MemberInfo) Reset()                    { *m = MemberInfo{} }
func (m *MemberInfo) String() string            { return proto.CompactTextString(m) }
func (*MemberInfo) ProtoMessage()               {}
func (*MemberInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *MemberInfo) GetLongMemberId() string {
	if m != nil {
		return m.LongMemberId
	}
	return ""
}

func (m *MemberInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *MemberInfo) GetShortMemberId() int32 {
	if m != nil {
		return m.ShortMemberId
	}
	return 0
}

func (m *MemberInfo) GetRaftPort() int32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *MemberInfo) GetRaftServicePort() int32 {
	if m != nil {
		return m.RaftServicePort
	}
	return 0
}

func (m *MemberInfo) GetGridPort() int32 {
	if m != nil {
		return m.GridPort
	}
	return 0
}

func (m *MemberInfo) GetSerfPort() int32 {
	if m != nil {
		return m.SerfPort
	}
	return 0
}

func (m *MemberInfo) GetRaftState() RaftState {
	if m != nil {
		return m.RaftState
	}
	return RaftState_Nonvoter
}

func (m *MemberInfo) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// This is the base raft command that can be sent.
// All actual commands need to appear in here and be part of this composition.
// Unfortunately that means that there's multiple places where messages need to be added.
// Here, on the sending side, and the receiving end. Well...you can't have everything in life.
type RaftCommand struct {
	// Types that are valid to be assigned to Cmd:
	//	*RaftCommand_GetCmd
	//	*RaftCommand_SetCmd
	//	*RaftCommand_DeleteCmd
	Cmd isRaftCommand_Cmd `protobuf_oneof:"cmd"`
}

func (m *RaftCommand) Reset()                    { *m = RaftCommand{} }
func (m *RaftCommand) String() string            { return proto.CompactTextString(m) }
func (*RaftCommand) ProtoMessage()               {}
func (*RaftCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type isRaftCommand_Cmd interface {
	isRaftCommand_Cmd()
}

type RaftCommand_GetCmd struct {
	GetCmd *GetCommand `protobuf:"bytes,1,opt,name=getCmd,oneof"`
}
type RaftCommand_SetCmd struct {
	SetCmd *SetCommand `protobuf:"bytes,2,opt,name=setCmd,oneof"`
}
type RaftCommand_DeleteCmd struct {
	DeleteCmd *DeleteCommand `protobuf:"bytes,3,opt,name=deleteCmd,oneof"`
}

func (*RaftCommand_GetCmd) isRaftCommand_Cmd()    {}
func (*RaftCommand_SetCmd) isRaftCommand_Cmd()    {}
func (*RaftCommand_DeleteCmd) isRaftCommand_Cmd() {}

func (m *RaftCommand) GetCmd() isRaftCommand_Cmd {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *RaftCommand) GetGetCmd() *GetCommand {
	if x, ok := m.GetCmd().(*RaftCommand_GetCmd); ok {
		return x.GetCmd
	}
	return nil
}

func (m *RaftCommand) GetSetCmd() *SetCommand {
	if x, ok := m.GetCmd().(*RaftCommand_SetCmd); ok {
		return x.SetCmd
	}
	return nil
}

func (m *RaftCommand) GetDeleteCmd() *DeleteCommand {
	if x, ok := m.GetCmd().(*RaftCommand_DeleteCmd); ok {
		return x.DeleteCmd
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RaftCommand) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RaftCommand_OneofMarshaler, _RaftCommand_OneofUnmarshaler, _RaftCommand_OneofSizer, []interface{}{
		(*RaftCommand_GetCmd)(nil),
		(*RaftCommand_SetCmd)(nil),
		(*RaftCommand_DeleteCmd)(nil),
	}
}

func _RaftCommand_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RaftCommand)
	// cmd
	switch x := m.Cmd.(type) {
	case *RaftCommand_GetCmd:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetCmd); err != nil {
			return err
		}
	case *RaftCommand_SetCmd:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SetCmd); err != nil {
			return err
		}
	case *RaftCommand_DeleteCmd:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeleteCmd); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RaftCommand.Cmd has unexpected type %T", x)
	}
	return nil
}

func _RaftCommand_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RaftCommand)
	switch tag {
	case 1: // cmd.getCmd
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetCommand)
		err := b.DecodeMessage(msg)
		m.Cmd = &RaftCommand_GetCmd{msg}
		return true, err
	case 2: // cmd.setCmd
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SetCommand)
		err := b.DecodeMessage(msg)
		m.Cmd = &RaftCommand_SetCmd{msg}
		return true, err
	case 3: // cmd.deleteCmd
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeleteCommand)
		err := b.DecodeMessage(msg)
		m.Cmd = &RaftCommand_DeleteCmd{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RaftCommand_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RaftCommand)
	// cmd
	switch x := m.Cmd.(type) {
	case *RaftCommand_GetCmd:
		s := proto.Size(x.GetCmd)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RaftCommand_SetCmd:
		s := proto.Size(x.SetCmd)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RaftCommand_DeleteCmd:
		s := proto.Size(x.DeleteCmd)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// This is "consistent get" message.
// The advantage is: This read will be up-to-date with the strongly consistent store.
// The bad part is: It need to travel to the leader, be processed, and replicated.
// Pretty expensive if you can live with stale data, do that instead.
type GetCommand struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *GetCommand) Reset()                    { *m = GetCommand{} }
func (m *GetCommand) String() string            { return proto.CompactTextString(m) }
func (*GetCommand) ProtoMessage()               {}
func (*GetCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *GetCommand) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// This sets a key-value-pair in the consistent store.
type SetCommand struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SetCommand) Reset()                    { *m = SetCommand{} }
func (m *SetCommand) String() string            { return proto.CompactTextString(m) }
func (*SetCommand) ProtoMessage()               {}
func (*SetCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *SetCommand) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SetCommand) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// This deletes a key-value-pair from the consistent store.
type DeleteCommand struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *DeleteCommand) Reset()                    { *m = DeleteCommand{} }
func (m *DeleteCommand) String() string            { return proto.CompactTextString(m) }
func (*DeleteCommand) ProtoMessage()               {}
func (*DeleteCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *DeleteCommand) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// I decided to cheap this out and make all of this a proto
type RaftSnapshot struct {
	Snap map[string][]byte `protobuf:"bytes,1,rep,name=snap" json:"snap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RaftSnapshot) Reset()                    { *m = RaftSnapshot{} }
func (m *RaftSnapshot) String() string            { return proto.CompactTextString(m) }
func (*RaftSnapshot) ProtoMessage()               {}
func (*RaftSnapshot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *RaftSnapshot) GetSnap() map[string][]byte {
	if m != nil {
		return m.Snap
	}
	return nil
}

type AllMembers struct {
	// all members of the cluster
	// long member id -> node info
	Members map[string]*MemberInfo `protobuf:"bytes,1,rep,name=members" json:"members,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AllMembers) Reset()                    { *m = AllMembers{} }
func (m *AllMembers) String() string            { return proto.CompactTextString(m) }
func (*AllMembers) ProtoMessage()               {}
func (*AllMembers) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *AllMembers) GetMembers() map[string]*MemberInfo {
	if m != nil {
		return m.Members
	}
	return nil
}

type RaftVoters struct {
	// a set of all voters in the raft cluster
	Voters map[string]bool `protobuf:"bytes,1,rep,name=voters" json:"voters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *RaftVoters) Reset()                    { *m = RaftVoters{} }
func (m *RaftVoters) String() string            { return proto.CompactTextString(m) }
func (*RaftVoters) ProtoMessage()               {}
func (*RaftVoters) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *RaftVoters) GetVoters() map[string]bool {
	if m != nil {
		return m.Voters
	}
	return nil
}

type RaftNonvoters struct {
	// a set of all nonvoters in the raft cluster
	Nonvoters map[string]bool `protobuf:"bytes,1,rep,name=nonvoters" json:"nonvoters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *RaftNonvoters) Reset()                    { *m = RaftNonvoters{} }
func (m *RaftNonvoters) String() string            { return proto.CompactTextString(m) }
func (*RaftNonvoters) ProtoMessage()               {}
func (*RaftNonvoters) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *RaftNonvoters) GetNonvoters() map[string]bool {
	if m != nil {
		return m.Nonvoters
	}
	return nil
}

type RaftVoterState struct {
	Voters    map[string]bool `protobuf:"bytes,1,rep,name=voters" json:"voters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Nonvoters map[string]bool `protobuf:"bytes,2,rep,name=nonvoters" json:"nonvoters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Nones     map[string]bool `protobuf:"bytes,3,rep,name=nones" json:"nones,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// This is not the most efficient implementation. But as long as we don't rely
	// on these updates to ship together through raft, we are free to make this better
	// as soon as this actually becomes a big problem.
	AllNodes map[string]*MemberInfo `protobuf:"bytes,4,rep,name=allNodes" json:"allNodes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RaftVoterState) Reset()                    { *m = RaftVoterState{} }
func (m *RaftVoterState) String() string            { return proto.CompactTextString(m) }
func (*RaftVoterState) ProtoMessage()               {}
func (*RaftVoterState) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *RaftVoterState) GetVoters() map[string]bool {
	if m != nil {
		return m.Voters
	}
	return nil
}

func (m *RaftVoterState) GetNonvoters() map[string]bool {
	if m != nil {
		return m.Nonvoters
	}
	return nil
}

func (m *RaftVoterState) GetNones() map[string]bool {
	if m != nil {
		return m.Nones
	}
	return nil
}

func (m *RaftVoterState) GetAllNodes() map[string]*MemberInfo {
	if m != nil {
		return m.AllNodes
	}
	return nil
}

type GetReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *GetReq) Reset()                    { *m = GetReq{} }
func (m *GetReq) String() string            { return proto.CompactTextString(m) }
func (*GetReq) ProtoMessage()               {}
func (*GetReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *GetReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type GetResp struct {
	Error RaftServiceError `protobuf:"varint,1,opt,name=error,enum=pb.RaftServiceError" json:"error,omitempty"`
	Value []byte           `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GetResp) Reset()                    { *m = GetResp{} }
func (m *GetResp) String() string            { return proto.CompactTextString(m) }
func (*GetResp) ProtoMessage()               {}
func (*GetResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *GetResp) GetError() RaftServiceError {
	if m != nil {
		return m.Error
	}
	return RaftServiceError_NoRaftError
}

func (m *GetResp) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type SetReq struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SetReq) Reset()                    { *m = SetReq{} }
func (m *SetReq) String() string            { return proto.CompactTextString(m) }
func (*SetReq) ProtoMessage()               {}
func (*SetReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

func (m *SetReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SetReq) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type SetResp struct {
	Error   RaftServiceError `protobuf:"varint,1,opt,name=error,enum=pb.RaftServiceError" json:"error,omitempty"`
	Created bool             `protobuf:"varint,2,opt,name=created" json:"created,omitempty"`
}

func (m *SetResp) Reset()                    { *m = SetResp{} }
func (m *SetResp) String() string            { return proto.CompactTextString(m) }
func (*SetResp) ProtoMessage()               {}
func (*SetResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

func (m *SetResp) GetError() RaftServiceError {
	if m != nil {
		return m.Error
	}
	return RaftServiceError_NoRaftError
}

func (m *SetResp) GetCreated() bool {
	if m != nil {
		return m.Created
	}
	return false
}

type DeleteReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *DeleteReq) Reset()                    { *m = DeleteReq{} }
func (m *DeleteReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteReq) ProtoMessage()               {}
func (*DeleteReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{14} }

func (m *DeleteReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type DeleteResp struct {
	Error   RaftServiceError `protobuf:"varint,1,opt,name=error,enum=pb.RaftServiceError" json:"error,omitempty"`
	Deleted bool             `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
}

func (m *DeleteResp) Reset()                    { *m = DeleteResp{} }
func (m *DeleteResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteResp) ProtoMessage()               {}
func (*DeleteResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{15} }

func (m *DeleteResp) GetError() RaftServiceError {
	if m != nil {
		return m.Error
	}
	return RaftServiceError_NoRaftError
}

func (m *DeleteResp) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func init() {
	proto.RegisterType((*MemberInfo)(nil), "pb.MemberInfo")
	proto.RegisterType((*RaftCommand)(nil), "pb.RaftCommand")
	proto.RegisterType((*GetCommand)(nil), "pb.GetCommand")
	proto.RegisterType((*SetCommand)(nil), "pb.SetCommand")
	proto.RegisterType((*DeleteCommand)(nil), "pb.DeleteCommand")
	proto.RegisterType((*RaftSnapshot)(nil), "pb.RaftSnapshot")
	proto.RegisterType((*AllMembers)(nil), "pb.AllMembers")
	proto.RegisterType((*RaftVoters)(nil), "pb.RaftVoters")
	proto.RegisterType((*RaftNonvoters)(nil), "pb.RaftNonvoters")
	proto.RegisterType((*RaftVoterState)(nil), "pb.RaftVoterState")
	proto.RegisterType((*GetReq)(nil), "pb.GetReq")
	proto.RegisterType((*GetResp)(nil), "pb.GetResp")
	proto.RegisterType((*SetReq)(nil), "pb.SetReq")
	proto.RegisterType((*SetResp)(nil), "pb.SetResp")
	proto.RegisterType((*DeleteReq)(nil), "pb.DeleteReq")
	proto.RegisterType((*DeleteResp)(nil), "pb.DeleteResp")
	proto.RegisterEnum("pb.RaftState", RaftState_name, RaftState_value)
	proto.RegisterEnum("pb.RaftServiceError", RaftServiceError_name, RaftServiceError_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RaftService service

type RaftServiceClient interface {
	Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error)
	ConsistentGet(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error)
	Set(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetResp, error)
	Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error)
}

type raftServiceClient struct {
	cc *grpc.ClientConn
}

func NewRaftServiceClient(cc *grpc.ClientConn) RaftServiceClient {
	return &raftServiceClient{cc}
}

func (c *raftServiceClient) Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error) {
	out := new(GetResp)
	err := grpc.Invoke(ctx, "/pb.RaftService/get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) ConsistentGet(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error) {
	out := new(GetResp)
	err := grpc.Invoke(ctx, "/pb.RaftService/consistentGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) Set(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetResp, error) {
	out := new(SetResp)
	err := grpc.Invoke(ctx, "/pb.RaftService/set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error) {
	out := new(DeleteResp)
	err := grpc.Invoke(ctx, "/pb.RaftService/delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RaftService service

type RaftServiceServer interface {
	Get(context.Context, *GetReq) (*GetResp, error)
	ConsistentGet(context.Context, *GetReq) (*GetResp, error)
	Set(context.Context, *SetReq) (*SetResp, error)
	Delete(context.Context, *DeleteReq) (*DeleteResp, error)
}

func RegisterRaftServiceServer(s *grpc.Server, srv RaftServiceServer) {
	s.RegisterService(&_RaftService_serviceDesc, srv)
}

func _RaftService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).Get(ctx, req.(*GetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_ConsistentGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).ConsistentGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftService/ConsistentGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).ConsistentGet(ctx, req.(*GetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).Set(ctx, req.(*SetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).Delete(ctx, req.(*DeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _RaftService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RaftService",
	HandlerType: (*RaftServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "get",
			Handler:    _RaftService_Get_Handler,
		},
		{
			MethodName: "consistentGet",
			Handler:    _RaftService_ConsistentGet_Handler,
		},
		{
			MethodName: "set",
			Handler:    _RaftService_Set_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _RaftService_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cluster_comm.proto",
}

func init() { proto.RegisterFile("cluster_comm.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 838 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xeb, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0x7a, 0x7d, 0xdb, 0xcf, 0x97, 0x9a, 0xa3, 0x0a, 0x56, 0x5b, 0xb5, 0x72, 0xad, 0xfe,
	0x30, 0x01, 0x59, 0xc5, 0xe5, 0x52, 0x50, 0x05, 0x2a, 0x6d, 0x14, 0x20, 0x10, 0xd0, 0x1a, 0x21,
	0xfe, 0xa1, 0x8d, 0x3d, 0x71, 0x22, 0x76, 0x77, 0xdc, 0x9d, 0x69, 0x20, 0xe2, 0x19, 0x10, 0x0f,
	0xc0, 0x0b, 0xf0, 0x90, 0xfd, 0x81, 0xe6, 0xb2, 0xb7, 0x60, 0x17, 0x42, 0x7e, 0xf9, 0x9c, 0xf3,
	0x7d, 0xe7, 0x3e, 0x3b, 0x63, 0xd0, 0x32, 0x7e, 0x29, 0x24, 0xcb, 0x7e, 0x5a, 0xf2, 0x24, 0x99,
	0x6d, 0x32, 0x2e, 0x39, 0x35, 0x36, 0x27, 0x93, 0x57, 0x0d, 0xe0, 0x1b, 0x96, 0x9c, 0xb0, 0xec,
	0xcb, 0xf4, 0x94, 0xd3, 0x04, 0xfd, 0x98, 0xa7, 0x6b, 0x6b, 0x59, 0xf9, 0xce, 0xd8, 0x99, 0x7a,
	0x61, 0xcd, 0x46, 0x84, 0xe6, 0x19, 0x17, 0xd2, 0x6f, 0x68, 0x4c, 0xcb, 0xf4, 0x00, 0x03, 0x71,
	0xc6, 0x33, 0x59, 0x38, 0xba, 0x63, 0x67, 0xda, 0x0a, 0xeb, 0x46, 0x0a, 0xd0, 0xcd, 0xa2, 0x53,
	0xf9, 0x1d, 0xcf, 0xa4, 0xdf, 0xd4, 0x84, 0x42, 0xa7, 0x29, 0x6e, 0x29, 0x79, 0xc1, 0xb2, 0x8b,
	0xf3, 0x25, 0xd3, 0x94, 0x96, 0xa6, 0x5c, 0x35, 0xab, 0x28, 0xeb, 0xec, 0x7c, 0xa5, 0x29, 0x6d,
	0x13, 0x25, 0xd7, 0x15, 0x26, 0x58, 0x76, 0xaa, 0xb1, 0x8e, 0xc1, 0x72, 0x9d, 0xde, 0x81, 0xa7,
	0x43, 0xc9, 0x48, 0x32, 0xbf, 0x3b, 0x76, 0xa6, 0xc3, 0xf9, 0x60, 0xb6, 0x39, 0x99, 0x85, 0xb9,
	0x31, 0x2c, 0x71, 0x7a, 0x17, 0x4d, 0x19, 0xad, 0x85, 0xef, 0x8d, 0xdd, 0x69, 0x6f, 0xee, 0x2b,
	0x5e, 0x39, 0xa6, 0xd9, 0xf7, 0xd1, 0x5a, 0x1c, 0xa4, 0x32, 0xbb, 0x0c, 0x35, 0x2b, 0xf8, 0x08,
	0x5e, 0x61, 0xa2, 0x11, 0xdc, 0x9f, 0xd9, 0xa5, 0x1d, 0x9d, 0x12, 0xe9, 0x36, 0x5a, 0x17, 0x51,
	0xfc, 0x92, 0xd9, 0x91, 0x19, 0xe5, 0x93, 0xc6, 0x63, 0x67, 0xf2, 0xa7, 0x83, 0x9e, 0xca, 0xff,
	0x8c, 0x27, 0x49, 0x94, 0xae, 0x68, 0x8a, 0xf6, 0x9a, 0xc9, 0x67, 0x89, 0x99, 0x7c, 0x6f, 0x3e,
	0x54, 0x89, 0x0f, 0x59, 0x8e, 0x7f, 0xb1, 0x17, 0x5a, 0x5c, 0x31, 0x85, 0x61, 0x36, 0x4a, 0xe6,
	0xa2, 0xc6, 0x34, 0x38, 0xbd, 0x07, 0x6f, 0xc5, 0x62, 0x26, 0x99, 0x22, 0xbb, 0x9a, 0xfc, 0x86,
	0x22, 0x3f, 0x37, 0xc6, 0x82, 0x5f, 0xb2, 0x3e, 0x6f, 0xc1, 0x5d, 0x26, 0xab, 0xc9, 0x3d, 0xa0,
	0xcc, 0xfd, 0xcf, 0xbe, 0x26, 0xef, 0x03, 0x8b, 0xd7, 0xe0, 0xf5, 0xbe, 0xfb, 0xb6, 0xef, 0xc9,
	0x7d, 0x0c, 0x6a, 0xa9, 0xb7, 0x04, 0xfe, 0x05, 0x7d, 0xbd, 0x95, 0x34, 0xda, 0x88, 0x33, 0x2e,
	0x69, 0x86, 0xa6, 0x48, 0xa3, 0x8d, 0xef, 0xe8, 0x6d, 0x04, 0xc5, 0xd6, 0x2c, 0x3e, 0x53, 0x82,
	0xdd, 0x87, 0xe2, 0xa9, 0x7d, 0x14, 0xa6, 0xff, 0x5a, 0x97, 0xde, 0xc7, 0x1f, 0x0e, 0xf0, 0x34,
	0x8e, 0xcd, 0xaa, 0x05, 0x7d, 0x80, 0x4e, 0x62, 0x44, 0x9b, 0xfa, 0x8e, 0x4a, 0x5d, 0x12, 0xec,
	0x99, 0xb0, 0x67, 0x21, 0xe7, 0x06, 0x5f, 0xa1, 0x5f, 0x05, 0xb6, 0x54, 0xf0, 0xa0, 0x5a, 0x81,
	0x5d, 0x5e, 0x79, 0xbe, 0xaa, 0x15, 0xfd, 0x06, 0xa8, 0x56, 0x7f, 0xe0, 0x52, 0x15, 0x34, 0x47,
	0xfb, 0x42, 0x4b, 0x57, 0x47, 0x61, 0xf0, 0x99, 0xf9, 0x31, 0xe5, 0x58, 0x66, 0xf0, 0x31, 0x7a,
	0x15, 0xf3, 0xbf, 0x8d, 0xa3, 0x5b, 0x4d, 0xfe, 0xbb, 0x83, 0x81, 0x8a, 0x7e, 0xcc, 0x53, 0x13,
	0x8c, 0x3e, 0x85, 0x97, 0xe6, 0x8a, 0xad, 0x61, 0x9c, 0xd7, 0x50, 0xb0, 0x66, 0x85, 0x64, 0x2a,
	0x29, 0x5d, 0x82, 0x27, 0x18, 0xd6, 0xc1, 0x6b, 0xd5, 0xf3, 0xca, 0xc5, 0xb0, 0xe8, 0xd6, 0x7c,
	0xa8, 0x1f, 0x5e, 0x99, 0xc8, 0xbd, 0xda, 0x44, 0x34, 0x67, 0xdb, 0x54, 0xe8, 0xb3, 0x6a, 0x23,
	0x0d, 0xed, 0x7a, 0x7f, 0x8b, 0xeb, 0xce, 0x4e, 0xe8, 0x11, 0x5a, 0x29, 0x4f, 0x99, 0xf0, 0x5d,
	0xed, 0x7c, 0x77, 0xbb, 0x33, 0xb3, 0x8e, 0x86, 0x4b, 0x4f, 0xd0, 0x8d, 0xe2, 0xf8, 0x98, 0xaf,
	0x98, 0xf0, 0x9b, 0xf5, 0xe9, 0x55, 0xfc, 0x9e, 0x5a, 0x8a, 0x71, 0x2d, 0x3c, 0x6e, 0xb0, 0xc9,
	0x9b, 0xcd, 0x3d, 0x78, 0x0c, 0x94, 0xbd, 0x5c, 0xcb, 0xf3, 0x08, 0x83, 0x5a, 0x37, 0x37, 0xfa,
	0x16, 0x02, 0xb4, 0x0f, 0x99, 0x0c, 0xd9, 0x8b, 0x2d, 0x57, 0xc6, 0x11, 0x3a, 0x1a, 0x13, 0x1b,
	0xda, 0x47, 0x8b, 0x65, 0x19, 0xcf, 0x34, 0x3c, 0x9c, 0xdf, 0x2e, 0xae, 0x0b, 0xf3, 0x88, 0x1c,
	0x28, 0x2c, 0x34, 0x94, 0x1d, 0x57, 0xd4, 0x43, 0xb4, 0x17, 0x3b, 0x12, 0xed, 0xf0, 0xf8, 0x16,
	0x9d, 0xc5, 0xff, 0x48, 0xef, 0xa3, 0xb3, 0xcc, 0x58, 0x24, 0xd9, 0xca, 0x8e, 0x2e, 0x57, 0x27,
	0x77, 0xe1, 0x99, 0x5b, 0x72, 0x7b, 0xbb, 0x21, 0x90, 0xc3, 0xd7, 0x4f, 0x69, 0x2e, 0xfa, 0x22,
	0xa5, 0x55, 0xf7, 0x1f, 0xc2, 0x2b, 0xde, 0x42, 0xea, 0xa3, 0x9b, 0x1f, 0x98, 0xd1, 0x1e, 0x79,
	0x68, 0xe9, 0x93, 0x37, 0x72, 0x08, 0x68, 0x7f, 0xcd, 0xa2, 0x15, 0xcb, 0x46, 0x8d, 0xfd, 0x1f,
	0x31, 0xba, 0x9a, 0x86, 0x6e, 0xa1, 0x77, 0xcc, 0x95, 0x55, 0xab, 0xa3, 0x3d, 0x7a, 0x13, 0x74,
	0xcc, 0xa5, 0xf1, 0x29, 0xed, 0x0e, 0xdd, 0xc1, 0x5b, 0x47, 0xec, 0xf2, 0x39, 0x67, 0x22, 0x95,
	0x07, 0xbf, 0x9e, 0x0b, 0x59, 0x82, 0x8d, 0xf9, 0x5f, 0xf6, 0x61, 0xb4, 0xa1, 0x69, 0x0c, 0x77,
	0xcd, 0x24, 0xc1, 0xbe, 0x87, 0x21, 0x7b, 0x11, 0xf4, 0x0a, 0x59, 0x6c, 0x26, 0x7b, 0xb4, 0x8f,
	0xc1, 0x92, 0xa7, 0xe2, 0x5c, 0x48, 0x96, 0xca, 0xc3, 0xd7, 0x73, 0xc7, 0x70, 0x45, 0xce, 0x58,
	0x54, 0x18, 0x8b, 0x82, 0xf1, 0x36, 0xda, 0x66, 0x2c, 0x34, 0x28, 0xdf, 0x4a, 0xc5, 0x1b, 0x56,
	0x55, 0x45, 0x3d, 0x69, 0xeb, 0x7f, 0x53, 0x8f, 0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x5a, 0x38,
	0x54, 0xae, 0x63, 0x09, 0x00, 0x00,
}
