// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cluster_comm.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This enum defines all raft operations.
//
type RaftOps int32

const (
	RaftOps_Set                      RaftOps = 0
	RaftOps_Delete                   RaftOps = 1
	RaftOps_ConsistentGet            RaftOps = 2
	RaftOps_AcquireUniqueShortNodeId RaftOps = 3
)

var RaftOps_name = map[int32]string{
	0: "Set",
	1: "Delete",
	2: "ConsistentGet",
	3: "AcquireUniqueShortNodeId",
}
var RaftOps_value = map[string]int32{
	"Set":                      0,
	"Delete":                   1,
	"ConsistentGet":            2,
	"AcquireUniqueShortNodeId": 3,
}

func (x RaftOps) String() string {
	return proto.EnumName(RaftOps_name, int32(x))
}
func (RaftOps) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type RaftServiceError int32

const (
	RaftServiceError_NotLeader RaftServiceError = 0
)

var RaftServiceError_name = map[int32]string{
	0: "NotLeader",
}
var RaftServiceError_value = map[string]int32{
	"NotLeader": 0,
}

func (x RaftServiceError) String() string {
	return proto.EnumName(RaftServiceError_name, int32(x))
}
func (RaftServiceError) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type NodeInfo struct {
	// contains hostname
	Host string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	// the unique id of a node
	NodeId int32 `protobuf:"varint,2,opt,name=nodeId" json:"nodeId,omitempty"`
	// the port on which the raft library operates
	RaftPort int32 `protobuf:"varint,3,opt,name=raftPort" json:"raftPort,omitempty"`
	// the port on which the grpc consensus protocol operates
	ValueServerPort int32 `protobuf:"varint,4,opt,name=valueServerPort" json:"valueServerPort,omitempty"`
	// the port on which the grid protocol operates
	GridPort int32 `protobuf:"varint,5,opt,name=gridPort" json:"gridPort,omitempty"`
	// the port on which serf operates
	SerfPort int32 `protobuf:"varint,6,opt,name=serfPort" json:"serfPort,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *NodeInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *NodeInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *NodeInfo) GetRaftPort() int32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *NodeInfo) GetValueServerPort() int32 {
	if m != nil {
		return m.ValueServerPort
	}
	return 0
}

func (m *NodeInfo) GetGridPort() int32 {
	if m != nil {
		return m.GridPort
	}
	return 0
}

func (m *NodeInfo) GetSerfPort() int32 {
	if m != nil {
		return m.SerfPort
	}
	return 0
}

// Generic container for raft commands.
// All operations need to be compressed somehow into this format.
type RaftCommand struct {
	Cmd   RaftOps `protobuf:"varint,1,opt,name=cmd,enum=pb.RaftOps" json:"cmd,omitempty"`
	Key   string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Value []byte  `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RaftCommand) Reset()                    { *m = RaftCommand{} }
func (m *RaftCommand) String() string            { return proto.CompactTextString(m) }
func (*RaftCommand) ProtoMessage()               {}
func (*RaftCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *RaftCommand) GetCmd() RaftOps {
	if m != nil {
		return m.Cmd
	}
	return RaftOps_Set
}

func (m *RaftCommand) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RaftCommand) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type RaftCommand2 struct {
	// Types that are valid to be assigned to Cmd:
	//	*RaftCommand2_GetCmd
	//	*RaftCommand2_SetCmd
	//	*RaftCommand2_DeleteCmd
	//	*RaftCommand2_NodeIdCmd
	Cmd isRaftCommand2_Cmd `protobuf_oneof:"cmd"`
}

func (m *RaftCommand2) Reset()                    { *m = RaftCommand2{} }
func (m *RaftCommand2) String() string            { return proto.CompactTextString(m) }
func (*RaftCommand2) ProtoMessage()               {}
func (*RaftCommand2) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

type isRaftCommand2_Cmd interface {
	isRaftCommand2_Cmd()
}

type RaftCommand2_GetCmd struct {
	GetCmd *GetCommand `protobuf:"bytes,1,opt,name=getCmd,oneof"`
}
type RaftCommand2_SetCmd struct {
	SetCmd *SetCommand `protobuf:"bytes,2,opt,name=setCmd,oneof"`
}
type RaftCommand2_DeleteCmd struct {
	DeleteCmd *DeleteCommand `protobuf:"bytes,3,opt,name=deleteCmd,oneof"`
}
type RaftCommand2_NodeIdCmd struct {
	NodeIdCmd *NodeIdCommand `protobuf:"bytes,4,opt,name=nodeIdCmd,oneof"`
}

func (*RaftCommand2_GetCmd) isRaftCommand2_Cmd()    {}
func (*RaftCommand2_SetCmd) isRaftCommand2_Cmd()    {}
func (*RaftCommand2_DeleteCmd) isRaftCommand2_Cmd() {}
func (*RaftCommand2_NodeIdCmd) isRaftCommand2_Cmd() {}

func (m *RaftCommand2) GetCmd() isRaftCommand2_Cmd {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *RaftCommand2) GetGetCmd() *GetCommand {
	if x, ok := m.GetCmd().(*RaftCommand2_GetCmd); ok {
		return x.GetCmd
	}
	return nil
}

func (m *RaftCommand2) GetSetCmd() *SetCommand {
	if x, ok := m.GetCmd().(*RaftCommand2_SetCmd); ok {
		return x.SetCmd
	}
	return nil
}

func (m *RaftCommand2) GetDeleteCmd() *DeleteCommand {
	if x, ok := m.GetCmd().(*RaftCommand2_DeleteCmd); ok {
		return x.DeleteCmd
	}
	return nil
}

func (m *RaftCommand2) GetNodeIdCmd() *NodeIdCommand {
	if x, ok := m.GetCmd().(*RaftCommand2_NodeIdCmd); ok {
		return x.NodeIdCmd
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RaftCommand2) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RaftCommand2_OneofMarshaler, _RaftCommand2_OneofUnmarshaler, _RaftCommand2_OneofSizer, []interface{}{
		(*RaftCommand2_GetCmd)(nil),
		(*RaftCommand2_SetCmd)(nil),
		(*RaftCommand2_DeleteCmd)(nil),
		(*RaftCommand2_NodeIdCmd)(nil),
	}
}

func _RaftCommand2_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RaftCommand2)
	// cmd
	switch x := m.Cmd.(type) {
	case *RaftCommand2_GetCmd:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetCmd); err != nil {
			return err
		}
	case *RaftCommand2_SetCmd:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SetCmd); err != nil {
			return err
		}
	case *RaftCommand2_DeleteCmd:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeleteCmd); err != nil {
			return err
		}
	case *RaftCommand2_NodeIdCmd:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NodeIdCmd); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RaftCommand2.Cmd has unexpected type %T", x)
	}
	return nil
}

func _RaftCommand2_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RaftCommand2)
	switch tag {
	case 1: // cmd.getCmd
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetCommand)
		err := b.DecodeMessage(msg)
		m.Cmd = &RaftCommand2_GetCmd{msg}
		return true, err
	case 2: // cmd.setCmd
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SetCommand)
		err := b.DecodeMessage(msg)
		m.Cmd = &RaftCommand2_SetCmd{msg}
		return true, err
	case 3: // cmd.deleteCmd
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeleteCommand)
		err := b.DecodeMessage(msg)
		m.Cmd = &RaftCommand2_DeleteCmd{msg}
		return true, err
	case 4: // cmd.nodeIdCmd
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NodeIdCommand)
		err := b.DecodeMessage(msg)
		m.Cmd = &RaftCommand2_NodeIdCmd{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RaftCommand2_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RaftCommand2)
	// cmd
	switch x := m.Cmd.(type) {
	case *RaftCommand2_GetCmd:
		s := proto.Size(x.GetCmd)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RaftCommand2_SetCmd:
		s := proto.Size(x.SetCmd)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RaftCommand2_DeleteCmd:
		s := proto.Size(x.DeleteCmd)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RaftCommand2_NodeIdCmd:
		s := proto.Size(x.NodeIdCmd)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetCommand struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *GetCommand) Reset()                    { *m = GetCommand{} }
func (m *GetCommand) String() string            { return proto.CompactTextString(m) }
func (*GetCommand) ProtoMessage()               {}
func (*GetCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *GetCommand) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type SetCommand struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SetCommand) Reset()                    { *m = SetCommand{} }
func (m *SetCommand) String() string            { return proto.CompactTextString(m) }
func (*SetCommand) ProtoMessage()               {}
func (*SetCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *SetCommand) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SetCommand) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type DeleteCommand struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *DeleteCommand) Reset()                    { *m = DeleteCommand{} }
func (m *DeleteCommand) String() string            { return proto.CompactTextString(m) }
func (*DeleteCommand) ProtoMessage()               {}
func (*DeleteCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *DeleteCommand) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type NodeIdCommand struct {
}

func (m *NodeIdCommand) Reset()                    { *m = NodeIdCommand{} }
func (m *NodeIdCommand) String() string            { return proto.CompactTextString(m) }
func (*NodeIdCommand) ProtoMessage()               {}
func (*NodeIdCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

// I decided to cheap this out and make all of this a proto
type RaftSnapshot struct {
	Snap map[string][]byte `protobuf:"bytes,1,rep,name=snap" json:"snap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RaftSnapshot) Reset()                    { *m = RaftSnapshot{} }
func (m *RaftSnapshot) String() string            { return proto.CompactTextString(m) }
func (*RaftSnapshot) ProtoMessage()               {}
func (*RaftSnapshot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *RaftSnapshot) GetSnap() map[string][]byte {
	if m != nil {
		return m.Snap
	}
	return nil
}

type GetReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *GetReq) Reset()                    { *m = GetReq{} }
func (m *GetReq) String() string            { return proto.CompactTextString(m) }
func (*GetReq) ProtoMessage()               {}
func (*GetReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *GetReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type GetResp struct {
	Error RaftServiceError `protobuf:"varint,1,opt,name=error,enum=pb.RaftServiceError" json:"error,omitempty"`
	Value []byte           `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GetResp) Reset()                    { *m = GetResp{} }
func (m *GetResp) String() string            { return proto.CompactTextString(m) }
func (*GetResp) ProtoMessage()               {}
func (*GetResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *GetResp) GetError() RaftServiceError {
	if m != nil {
		return m.Error
	}
	return RaftServiceError_NotLeader
}

func (m *GetResp) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type SetReq struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SetReq) Reset()                    { *m = SetReq{} }
func (m *SetReq) String() string            { return proto.CompactTextString(m) }
func (*SetReq) ProtoMessage()               {}
func (*SetReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *SetReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SetReq) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type SetResp struct {
	Error   RaftServiceError `protobuf:"varint,1,opt,name=error,enum=pb.RaftServiceError" json:"error,omitempty"`
	Created bool             `protobuf:"varint,2,opt,name=created" json:"created,omitempty"`
}

func (m *SetResp) Reset()                    { *m = SetResp{} }
func (m *SetResp) String() string            { return proto.CompactTextString(m) }
func (*SetResp) ProtoMessage()               {}
func (*SetResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *SetResp) GetError() RaftServiceError {
	if m != nil {
		return m.Error
	}
	return RaftServiceError_NotLeader
}

func (m *SetResp) GetCreated() bool {
	if m != nil {
		return m.Created
	}
	return false
}

type DeleteReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *DeleteReq) Reset()                    { *m = DeleteReq{} }
func (m *DeleteReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteReq) ProtoMessage()               {}
func (*DeleteReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

func (m *DeleteReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type DeleteResp struct {
	Error   RaftServiceError `protobuf:"varint,1,opt,name=error,enum=pb.RaftServiceError" json:"error,omitempty"`
	Deleted bool             `protobuf:"varint,2,opt,name=deleted" json:"deleted,omitempty"`
}

func (m *DeleteResp) Reset()                    { *m = DeleteResp{} }
func (m *DeleteResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteResp) ProtoMessage()               {}
func (*DeleteResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

func (m *DeleteResp) GetError() RaftServiceError {
	if m != nil {
		return m.Error
	}
	return RaftServiceError_NotLeader
}

func (m *DeleteResp) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

type AcquireUniqueShortNodeIdReq struct {
}

func (m *AcquireUniqueShortNodeIdReq) Reset()                    { *m = AcquireUniqueShortNodeIdReq{} }
func (m *AcquireUniqueShortNodeIdReq) String() string            { return proto.CompactTextString(m) }
func (*AcquireUniqueShortNodeIdReq) ProtoMessage()               {}
func (*AcquireUniqueShortNodeIdReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{14} }

type AcquireUniqueShortNodeIdResp struct {
	Error  RaftServiceError `protobuf:"varint,1,opt,name=error,enum=pb.RaftServiceError" json:"error,omitempty"`
	NodeId int32            `protobuf:"varint,2,opt,name=nodeId" json:"nodeId,omitempty"`
}

func (m *AcquireUniqueShortNodeIdResp) Reset()                    { *m = AcquireUniqueShortNodeIdResp{} }
func (m *AcquireUniqueShortNodeIdResp) String() string            { return proto.CompactTextString(m) }
func (*AcquireUniqueShortNodeIdResp) ProtoMessage()               {}
func (*AcquireUniqueShortNodeIdResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{15} }

func (m *AcquireUniqueShortNodeIdResp) GetError() RaftServiceError {
	if m != nil {
		return m.Error
	}
	return RaftServiceError_NotLeader
}

func (m *AcquireUniqueShortNodeIdResp) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func init() {
	proto.RegisterType((*NodeInfo)(nil), "pb.NodeInfo")
	proto.RegisterType((*RaftCommand)(nil), "pb.RaftCommand")
	proto.RegisterType((*RaftCommand2)(nil), "pb.RaftCommand2")
	proto.RegisterType((*GetCommand)(nil), "pb.GetCommand")
	proto.RegisterType((*SetCommand)(nil), "pb.SetCommand")
	proto.RegisterType((*DeleteCommand)(nil), "pb.DeleteCommand")
	proto.RegisterType((*NodeIdCommand)(nil), "pb.NodeIdCommand")
	proto.RegisterType((*RaftSnapshot)(nil), "pb.RaftSnapshot")
	proto.RegisterType((*GetReq)(nil), "pb.GetReq")
	proto.RegisterType((*GetResp)(nil), "pb.GetResp")
	proto.RegisterType((*SetReq)(nil), "pb.SetReq")
	proto.RegisterType((*SetResp)(nil), "pb.SetResp")
	proto.RegisterType((*DeleteReq)(nil), "pb.DeleteReq")
	proto.RegisterType((*DeleteResp)(nil), "pb.DeleteResp")
	proto.RegisterType((*AcquireUniqueShortNodeIdReq)(nil), "pb.AcquireUniqueShortNodeIdReq")
	proto.RegisterType((*AcquireUniqueShortNodeIdResp)(nil), "pb.AcquireUniqueShortNodeIdResp")
	proto.RegisterEnum("pb.RaftOps", RaftOps_name, RaftOps_value)
	proto.RegisterEnum("pb.RaftServiceError", RaftServiceError_name, RaftServiceError_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RaftService service

type RaftServiceClient interface {
	Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error)
	ConsistentGet(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error)
	Set(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetResp, error)
	Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error)
	AcquireUniqueShortNodeId(ctx context.Context, in *AcquireUniqueShortNodeIdReq, opts ...grpc.CallOption) (*AcquireUniqueShortNodeIdResp, error)
}

type raftServiceClient struct {
	cc *grpc.ClientConn
}

func NewRaftServiceClient(cc *grpc.ClientConn) RaftServiceClient {
	return &raftServiceClient{cc}
}

func (c *raftServiceClient) Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error) {
	out := new(GetResp)
	err := grpc.Invoke(ctx, "/pb.RaftService/get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) ConsistentGet(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error) {
	out := new(GetResp)
	err := grpc.Invoke(ctx, "/pb.RaftService/consistentGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) Set(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetResp, error) {
	out := new(SetResp)
	err := grpc.Invoke(ctx, "/pb.RaftService/set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error) {
	out := new(DeleteResp)
	err := grpc.Invoke(ctx, "/pb.RaftService/delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) AcquireUniqueShortNodeId(ctx context.Context, in *AcquireUniqueShortNodeIdReq, opts ...grpc.CallOption) (*AcquireUniqueShortNodeIdResp, error) {
	out := new(AcquireUniqueShortNodeIdResp)
	err := grpc.Invoke(ctx, "/pb.RaftService/acquireUniqueShortNodeId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RaftService service

type RaftServiceServer interface {
	Get(context.Context, *GetReq) (*GetResp, error)
	ConsistentGet(context.Context, *GetReq) (*GetResp, error)
	Set(context.Context, *SetReq) (*SetResp, error)
	Delete(context.Context, *DeleteReq) (*DeleteResp, error)
	AcquireUniqueShortNodeId(context.Context, *AcquireUniqueShortNodeIdReq) (*AcquireUniqueShortNodeIdResp, error)
}

func RegisterRaftServiceServer(s *grpc.Server, srv RaftServiceServer) {
	s.RegisterService(&_RaftService_serviceDesc, srv)
}

func _RaftService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftService/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).Get(ctx, req.(*GetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_ConsistentGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).ConsistentGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftService/ConsistentGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).ConsistentGet(ctx, req.(*GetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftService/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).Set(ctx, req.(*SetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).Delete(ctx, req.(*DeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_AcquireUniqueShortNodeId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcquireUniqueShortNodeIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).AcquireUniqueShortNodeId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftService/AcquireUniqueShortNodeId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).AcquireUniqueShortNodeId(ctx, req.(*AcquireUniqueShortNodeIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _RaftService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RaftService",
	HandlerType: (*RaftServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "get",
			Handler:    _RaftService_Get_Handler,
		},
		{
			MethodName: "consistentGet",
			Handler:    _RaftService_ConsistentGet_Handler,
		},
		{
			MethodName: "set",
			Handler:    _RaftService_Set_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _RaftService_Delete_Handler,
		},
		{
			MethodName: "acquireUniqueShortNodeId",
			Handler:    _RaftService_AcquireUniqueShortNodeId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cluster_comm.proto",
}

func init() { proto.RegisterFile("cluster_comm.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 641 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0xdf, 0x6e, 0xd3, 0x30,
	0x14, 0xc6, 0x9b, 0xa4, 0x4d, 0xd7, 0xd3, 0x75, 0xcb, 0xac, 0x09, 0x45, 0x65, 0x83, 0x2c, 0x57,
	0xa5, 0x17, 0x15, 0x14, 0x24, 0x10, 0x77, 0x30, 0xa6, 0x81, 0x40, 0x1b, 0x72, 0xe0, 0x7a, 0x4a,
	0x93, 0xd3, 0xad, 0x62, 0x8d, 0x53, 0xc7, 0x1d, 0xda, 0x23, 0xf0, 0x3e, 0xbc, 0x07, 0xaf, 0x84,
	0x6c, 0xe7, 0x4f, 0x37, 0x35, 0x15, 0xe3, 0xce, 0xc7, 0xdf, 0xcf, 0xe7, 0x7c, 0x3e, 0x27, 0x75,
	0x81, 0x44, 0xd7, 0xcb, 0x4c, 0x20, 0xbf, 0x88, 0xd8, 0x7c, 0x3e, 0x4a, 0x39, 0x13, 0x8c, 0x98,
	0xe9, 0xc4, 0xff, 0x6d, 0xc0, 0xd6, 0x19, 0x8b, 0xf1, 0x53, 0x32, 0x65, 0x84, 0x40, 0xf3, 0x8a,
	0x65, 0xc2, 0x35, 0x3c, 0x63, 0xd0, 0xa1, 0x6a, 0x4d, 0x1e, 0x81, 0x9d, 0x48, 0x3d, 0x76, 0x4d,
	0xcf, 0x18, 0xb4, 0x68, 0x1e, 0x91, 0x3e, 0x6c, 0xf1, 0x70, 0x2a, 0xbe, 0x32, 0x2e, 0x5c, 0x4b,
	0x29, 0x65, 0x4c, 0x06, 0xb0, 0x7b, 0x13, 0x5e, 0x2f, 0x31, 0x40, 0x7e, 0x83, 0x5c, 0x21, 0x4d,
	0x85, 0xdc, 0xdf, 0x96, 0x59, 0x2e, 0xf9, 0x2c, 0x56, 0x48, 0x4b, 0x67, 0x29, 0x62, 0xa9, 0x65,
	0xc8, 0xa7, 0x4a, 0xb3, 0xb5, 0x56, 0xc4, 0xfe, 0x37, 0xe8, 0xd2, 0x70, 0x2a, 0x8e, 0xd9, 0x7c,
	0x1e, 0x26, 0x31, 0x39, 0x04, 0x2b, 0x9a, 0xc7, 0xca, 0xf7, 0xce, 0xb8, 0x3b, 0x4a, 0x27, 0x23,
	0xa9, 0x9e, 0xa7, 0x19, 0x95, 0xfb, 0xc4, 0x01, 0xeb, 0x07, 0xde, 0xaa, 0x0b, 0x74, 0xa8, 0x5c,
	0x92, 0x7d, 0x68, 0x29, 0x2b, 0xca, 0xfa, 0x36, 0xd5, 0x81, 0xff, 0xc7, 0x80, 0xed, 0x95, 0xb4,
	0x63, 0x32, 0x00, 0xfb, 0x12, 0xc5, 0x71, 0x9e, 0xba, 0x3b, 0xde, 0x91, 0xa9, 0x4f, 0xb1, 0x00,
	0x3e, 0x36, 0x68, 0xae, 0x4b, 0x32, 0xd3, 0xa4, 0x59, 0x91, 0xc1, 0x1d, 0x52, 0xeb, 0xe4, 0x05,
	0x74, 0x62, 0xbc, 0x46, 0x81, 0x12, 0xb6, 0x14, 0xbc, 0x27, 0xe1, 0x0f, 0x7a, 0xb3, 0xe4, 0x2b,
	0x4a, 0x1e, 0xd1, 0x5d, 0x97, 0x47, 0x9a, 0xd5, 0x91, 0x33, 0xbd, 0x59, 0x1d, 0x29, 0xa9, 0xf7,
	0x2d, 0xd5, 0x11, 0xff, 0x09, 0x40, 0x65, 0xb7, 0xe8, 0x83, 0x51, 0xf6, 0xc1, 0x7f, 0x05, 0x10,
	0x6c, 0xd0, 0xab, 0x3e, 0x99, 0xab, 0x7d, 0x3a, 0x82, 0xde, 0x1d, 0xb7, 0x6b, 0x12, 0xef, 0x42,
	0xef, 0x8e, 0x3b, 0xff, 0xa7, 0x6e, 0x6d, 0x90, 0x84, 0x69, 0x76, 0xc5, 0x04, 0x19, 0x41, 0x33,
	0x4b, 0xc2, 0xd4, 0x35, 0x3c, 0x6b, 0xd0, 0x1d, 0xf7, 0x8b, 0x99, 0x15, 0xfa, 0x48, 0x2e, 0x4e,
	0x12, 0xc1, 0x6f, 0xa9, 0xe2, 0xfa, 0xaf, 0xa1, 0x53, 0x6e, 0xfd, 0xab, 0xd1, 0xb7, 0xe6, 0x1b,
	0xc3, 0xef, 0x83, 0x7d, 0x8a, 0x82, 0xe2, 0x62, 0x8d, 0xcb, 0xcf, 0xd0, 0x56, 0x5a, 0x96, 0x92,
	0x21, 0xb4, 0x90, 0x73, 0xc6, 0xf3, 0x8f, 0x68, 0xbf, 0x34, 0x84, 0xfc, 0x66, 0x16, 0xe1, 0x89,
	0xd4, 0xa8, 0x46, 0x6a, 0xba, 0xf2, 0x1c, 0xec, 0xa0, 0xa6, 0x50, 0xcd, 0x89, 0x73, 0x68, 0x07,
	0xff, 0x51, 0xde, 0x85, 0x76, 0xc4, 0x31, 0x14, 0xa8, 0x3f, 0xb6, 0x2d, 0x5a, 0x84, 0xfe, 0x21,
	0x74, 0xf4, 0x60, 0xd6, 0x5f, 0x97, 0x02, 0x14, 0xf2, 0xc3, 0x4b, 0xea, 0xcf, 0xb1, 0x2c, 0x99,
	0x87, 0xfe, 0x21, 0x3c, 0x7e, 0x17, 0x2d, 0x96, 0x33, 0x8e, 0xdf, 0x93, 0xd9, 0x62, 0x89, 0xc1,
	0x15, 0xe3, 0x42, 0x8f, 0x9e, 0xe2, 0xc2, 0x9f, 0xc0, 0x41, 0xbd, 0xfc, 0x40, 0x13, 0x35, 0x4f,
	0xd1, 0xf0, 0x1c, 0xda, 0xf9, 0xcf, 0x9d, 0xb4, 0xc1, 0x0a, 0x50, 0x38, 0x0d, 0x02, 0x60, 0xeb,
	0xab, 0x3a, 0x06, 0xd9, 0x83, 0xde, 0x31, 0x4b, 0xb2, 0x59, 0x26, 0x30, 0x11, 0xa7, 0x28, 0x1c,
	0x93, 0x1c, 0x80, 0x5b, 0x67, 0xcb, 0xb1, 0x86, 0x47, 0xe0, 0xdc, 0xf7, 0x40, 0x7a, 0xd0, 0x39,
	0x63, 0xe2, 0x0b, 0x86, 0x31, 0x72, 0xa7, 0x31, 0xfe, 0x65, 0xea, 0x17, 0x28, 0x67, 0x88, 0x07,
	0xd6, 0x25, 0x0a, 0x02, 0xf9, 0x03, 0x41, 0x71, 0xd1, 0xef, 0x96, 0xeb, 0x2c, 0xf5, 0x1b, 0x64,
	0x08, 0xbd, 0x68, 0xd5, 0xc5, 0x26, 0xd6, 0x03, 0x2b, 0x2b, 0x88, 0x60, 0x85, 0x08, 0x4a, 0xe2,
	0x19, 0xd8, 0x7a, 0x02, 0xa4, 0x57, 0x3d, 0x1e, 0x92, 0xdb, 0x59, 0x0d, 0x15, 0x7a, 0x01, 0x6e,
	0x58, 0x73, 0x57, 0xf2, 0x54, 0xd2, 0x1b, 0xe6, 0xd7, 0xf7, 0x36, 0x03, 0xb2, 0xc0, 0xc4, 0x56,
	0x7f, 0x27, 0x2f, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0xc6, 0x9d, 0x4b, 0x73, 0x64, 0x06, 0x00,
	0x00,
}
