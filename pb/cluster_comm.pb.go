// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cluster_comm.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// these are the only two raft operations possible
type RaftOps int32

const (
	RaftOps_Set    RaftOps = 0
	RaftOps_Delete RaftOps = 1
)

var RaftOps_name = map[int32]string{
	0: "Set",
	1: "Delete",
}
var RaftOps_value = map[string]int32{
	"Set":    0,
	"Delete": 1,
}

func (x RaftOps) String() string {
	return proto.EnumName(RaftOps_name, int32(x))
}
func (RaftOps) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type NodeInfo struct {
	// contains hostname
	Host string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	// the unique id of a node
	NodeId int32 `protobuf:"varint,2,opt,name=nodeId" json:"nodeId,omitempty"`
	// the port on which the raft library operates
	RaftPort int32 `protobuf:"varint,3,opt,name=raftPort" json:"raftPort,omitempty"`
	// the port on which the grpc consensus protocol operates
	ValueServerPort int32 `protobuf:"varint,4,opt,name=valueServerPort" json:"valueServerPort,omitempty"`
	// the port on which the grid protocol operates
	GridPort int32 `protobuf:"varint,5,opt,name=gridPort" json:"gridPort,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *NodeInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *NodeInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *NodeInfo) GetRaftPort() int32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *NodeInfo) GetValueServerPort() int32 {
	if m != nil {
		return m.ValueServerPort
	}
	return 0
}

func (m *NodeInfo) GetGridPort() int32 {
	if m != nil {
		return m.GridPort
	}
	return 0
}

// the raft api enforces string as key and value type
type RaftCommand struct {
	Cmd   RaftOps `protobuf:"varint,1,opt,name=cmd,enum=pb.RaftOps" json:"cmd,omitempty"`
	Key   string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Value []byte  `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RaftCommand) Reset()                    { *m = RaftCommand{} }
func (m *RaftCommand) String() string            { return proto.CompactTextString(m) }
func (*RaftCommand) ProtoMessage()               {}
func (*RaftCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *RaftCommand) GetCmd() RaftOps {
	if m != nil {
		return m.Cmd
	}
	return RaftOps_Set
}

func (m *RaftCommand) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RaftCommand) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// I decided to cheap this out and make all of this a proto
type RaftSnapshot struct {
	Snap map[string][]byte `protobuf:"bytes,1,rep,name=snap" json:"snap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RaftSnapshot) Reset()                    { *m = RaftSnapshot{} }
func (m *RaftSnapshot) String() string            { return proto.CompactTextString(m) }
func (*RaftSnapshot) ProtoMessage()               {}
func (*RaftSnapshot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *RaftSnapshot) GetSnap() map[string][]byte {
	if m != nil {
		return m.Snap
	}
	return nil
}

type RaftJoinRequest struct {
	Host string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	Id   string `protobuf:"bytes,3,opt,name=id" json:"id,omitempty"`
}

func (m *RaftJoinRequest) Reset()                    { *m = RaftJoinRequest{} }
func (m *RaftJoinRequest) String() string            { return proto.CompactTextString(m) }
func (*RaftJoinRequest) ProtoMessage()               {}
func (*RaftJoinRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *RaftJoinRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *RaftJoinRequest) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *RaftJoinRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type RaftJoinResponse struct {
	Ok    bool   `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *RaftJoinResponse) Reset()                    { *m = RaftJoinResponse{} }
func (m *RaftJoinResponse) String() string            { return proto.CompactTextString(m) }
func (*RaftJoinResponse) ProtoMessage()               {}
func (*RaftJoinResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *RaftJoinResponse) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *RaftJoinResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type GetReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *GetReq) Reset()                    { *m = GetReq{} }
func (m *GetReq) String() string            { return proto.CompactTextString(m) }
func (*GetReq) ProtoMessage()               {}
func (*GetReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *GetReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type GetResp struct {
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GetResp) Reset()                    { *m = GetResp{} }
func (m *GetResp) String() string            { return proto.CompactTextString(m) }
func (*GetResp) ProtoMessage()               {}
func (*GetResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *GetResp) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type SetReq struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SetReq) Reset()                    { *m = SetReq{} }
func (m *SetReq) String() string            { return proto.CompactTextString(m) }
func (*SetReq) ProtoMessage()               {}
func (*SetReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *SetReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SetReq) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type SetResp struct {
	Created bool `protobuf:"varint,1,opt,name=created" json:"created,omitempty"`
}

func (m *SetResp) Reset()                    { *m = SetResp{} }
func (m *SetResp) String() string            { return proto.CompactTextString(m) }
func (*SetResp) ProtoMessage()               {}
func (*SetResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *SetResp) GetCreated() bool {
	if m != nil {
		return m.Created
	}
	return false
}

type DeleteReq struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *DeleteReq) Reset()                    { *m = DeleteReq{} }
func (m *DeleteReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteReq) ProtoMessage()               {}
func (*DeleteReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *DeleteReq) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type DeleteResp struct {
	Deleted bool `protobuf:"varint,1,opt,name=deleted" json:"deleted,omitempty"`
}

func (m *DeleteResp) Reset()                    { *m = DeleteResp{} }
func (m *DeleteResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteResp) ProtoMessage()               {}
func (*DeleteResp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func (m *DeleteResp) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func init() {
	proto.RegisterType((*NodeInfo)(nil), "pb.NodeInfo")
	proto.RegisterType((*RaftCommand)(nil), "pb.RaftCommand")
	proto.RegisterType((*RaftSnapshot)(nil), "pb.RaftSnapshot")
	proto.RegisterType((*RaftJoinRequest)(nil), "pb.RaftJoinRequest")
	proto.RegisterType((*RaftJoinResponse)(nil), "pb.RaftJoinResponse")
	proto.RegisterType((*GetReq)(nil), "pb.GetReq")
	proto.RegisterType((*GetResp)(nil), "pb.GetResp")
	proto.RegisterType((*SetReq)(nil), "pb.SetReq")
	proto.RegisterType((*SetResp)(nil), "pb.SetResp")
	proto.RegisterType((*DeleteReq)(nil), "pb.DeleteReq")
	proto.RegisterType((*DeleteResp)(nil), "pb.DeleteResp")
	proto.RegisterEnum("pb.RaftOps", RaftOps_name, RaftOps_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RaftCluster service

type RaftClusterClient interface {
	// A new node is supposed to join this RPC to join the raft cluster if it wishes so.
	// Every node in the cluster exposes this API and calling it on peers that have been provided to you,
	// sounds like a good idea. The receiving node will try to forward the request to the actual raft leader.
	// The raft leader then adds the new node to the cluster (if appropriate) and sends back an ok.
	// The forward nature of this call is completely transparent to the caller.
	JoinRaftCluster(ctx context.Context, in *RaftJoinRequest, opts ...grpc.CallOption) (*RaftJoinResponse, error)
	Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error)
	Set(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetResp, error)
	Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error)
}

type raftClusterClient struct {
	cc *grpc.ClientConn
}

func NewRaftClusterClient(cc *grpc.ClientConn) RaftClusterClient {
	return &raftClusterClient{cc}
}

func (c *raftClusterClient) JoinRaftCluster(ctx context.Context, in *RaftJoinRequest, opts ...grpc.CallOption) (*RaftJoinResponse, error) {
	out := new(RaftJoinResponse)
	err := grpc.Invoke(ctx, "/pb.RaftCluster/joinRaftCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClusterClient) Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetResp, error) {
	out := new(GetResp)
	err := grpc.Invoke(ctx, "/pb.RaftCluster/get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClusterClient) Set(ctx context.Context, in *SetReq, opts ...grpc.CallOption) (*SetResp, error) {
	out := new(SetResp)
	err := grpc.Invoke(ctx, "/pb.RaftCluster/set", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftClusterClient) Delete(ctx context.Context, in *DeleteReq, opts ...grpc.CallOption) (*DeleteResp, error) {
	out := new(DeleteResp)
	err := grpc.Invoke(ctx, "/pb.RaftCluster/delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RaftCluster service

type RaftClusterServer interface {
	// A new node is supposed to join this RPC to join the raft cluster if it wishes so.
	// Every node in the cluster exposes this API and calling it on peers that have been provided to you,
	// sounds like a good idea. The receiving node will try to forward the request to the actual raft leader.
	// The raft leader then adds the new node to the cluster (if appropriate) and sends back an ok.
	// The forward nature of this call is completely transparent to the caller.
	JoinRaftCluster(context.Context, *RaftJoinRequest) (*RaftJoinResponse, error)
	Get(context.Context, *GetReq) (*GetResp, error)
	Set(context.Context, *SetReq) (*SetResp, error)
	Delete(context.Context, *DeleteReq) (*DeleteResp, error)
}

func RegisterRaftClusterServer(s *grpc.Server, srv RaftClusterServer) {
	s.RegisterService(&_RaftCluster_serviceDesc, srv)
}

func _RaftCluster_JoinRaftCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftJoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftClusterServer).JoinRaftCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftCluster/JoinRaftCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftClusterServer).JoinRaftCluster(ctx, req.(*RaftJoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftCluster_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftClusterServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftCluster/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftClusterServer).Get(ctx, req.(*GetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftCluster_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftClusterServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftCluster/Set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftClusterServer).Set(ctx, req.(*SetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftCluster_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftClusterServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.RaftCluster/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftClusterServer).Delete(ctx, req.(*DeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _RaftCluster_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.RaftCluster",
	HandlerType: (*RaftClusterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "joinRaftCluster",
			Handler:    _RaftCluster_JoinRaftCluster_Handler,
		},
		{
			MethodName: "get",
			Handler:    _RaftCluster_Get_Handler,
		},
		{
			MethodName: "set",
			Handler:    _RaftCluster_Set_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _RaftCluster_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cluster_comm.proto",
}

func init() { proto.RegisterFile("cluster_comm.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 493 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x53, 0x41, 0x8f, 0xd3, 0x3c,
	0x10, 0x5d, 0x27, 0x6d, 0xda, 0x4e, 0xf7, 0x6b, 0x2b, 0x7f, 0x2b, 0x14, 0x45, 0x5a, 0xa8, 0x8c,
	0x84, 0x0a, 0x87, 0x08, 0x95, 0x03, 0x2b, 0x0e, 0x5c, 0x00, 0xa1, 0xe5, 0x00, 0xc8, 0xe1, 0x8e,
	0xd2, 0x66, 0xba, 0x5b, 0xda, 0xc4, 0x5e, 0xdb, 0x5d, 0xb4, 0xff, 0x84, 0x1f, 0xc3, 0x8f, 0x43,
	0xb6, 0x93, 0x6c, 0x80, 0x72, 0x9b, 0x37, 0xf3, 0xfc, 0xe6, 0xf9, 0x25, 0x06, 0xba, 0xde, 0x1f,
	0xb4, 0x41, 0xf5, 0x75, 0x2d, 0xca, 0x32, 0x95, 0x4a, 0x18, 0x41, 0x03, 0xb9, 0x62, 0x3f, 0x08,
	0x0c, 0x3f, 0x8a, 0x02, 0x2f, 0xab, 0x8d, 0xa0, 0x14, 0x7a, 0xd7, 0x42, 0x9b, 0x98, 0xcc, 0xc9,
	0x62, 0xc4, 0x5d, 0x4d, 0x1f, 0x40, 0x54, 0xd9, 0x79, 0x11, 0x07, 0x73, 0xb2, 0xe8, 0xf3, 0x1a,
	0xd1, 0x04, 0x86, 0x2a, 0xdf, 0x98, 0xcf, 0x42, 0x99, 0x38, 0x74, 0x93, 0x16, 0xd3, 0x05, 0x4c,
	0x6f, 0xf3, 0xfd, 0x01, 0x33, 0x54, 0xb7, 0xa8, 0x1c, 0xa5, 0xe7, 0x28, 0x7f, 0xb6, 0xad, 0xca,
	0x95, 0xda, 0x16, 0x8e, 0xd2, 0xf7, 0x2a, 0x0d, 0x66, 0x5f, 0x60, 0xcc, 0xf3, 0x8d, 0x79, 0x23,
	0xca, 0x32, 0xaf, 0x0a, 0x7a, 0x0e, 0xe1, 0xba, 0x2c, 0x9c, 0xb7, 0xc9, 0x72, 0x9c, 0xca, 0x55,
	0x6a, 0xa7, 0x9f, 0xa4, 0xe6, 0xb6, 0x4f, 0x67, 0x10, 0xee, 0xf0, 0xce, 0x99, 0x1c, 0x71, 0x5b,
	0xd2, 0x33, 0xe8, 0xbb, 0x75, 0xce, 0xde, 0x29, 0xf7, 0x80, 0x7d, 0x87, 0x53, 0x7b, 0x2e, 0xab,
	0x72, 0xa9, 0xaf, 0x85, 0xa1, 0x29, 0xf4, 0x74, 0x95, 0xcb, 0x98, 0xcc, 0xc3, 0xc5, 0x78, 0x99,
	0x34, 0xba, 0xcd, 0x3c, 0xb5, 0xc5, 0xbb, 0xca, 0xa8, 0x3b, 0xee, 0x78, 0xc9, 0x4b, 0x18, 0xb5,
	0xad, 0x66, 0x29, 0x39, 0xb2, 0x34, 0xe8, 0x2c, 0x7d, 0x15, 0x5c, 0x10, 0x76, 0x09, 0x53, 0x2b,
	0xfc, 0x41, 0x6c, 0x2b, 0x8e, 0x37, 0x07, 0xd4, 0xe6, 0x68, 0xde, 0x14, 0x7a, 0xd2, 0xa6, 0xe1,
	0xd3, 0x76, 0x35, 0x9d, 0x40, 0xb0, 0x2d, 0xdc, 0x35, 0x46, 0x3c, 0xd8, 0x16, 0xec, 0x02, 0x66,
	0xf7, 0x52, 0x5a, 0x8a, 0x4a, 0xa3, 0xe5, 0x88, 0x9d, 0x53, 0x1a, 0xf2, 0x40, 0xec, 0xac, 0x11,
	0x54, 0x4a, 0xa8, 0x3a, 0x11, 0x0f, 0x58, 0x02, 0xd1, 0x7b, 0x34, 0x1c, 0x6f, 0xfe, 0xb6, 0xce,
	0x1e, 0xc1, 0xc0, 0xcd, 0xb4, 0xbc, 0xbf, 0x05, 0xe9, 0x46, 0xf7, 0x1c, 0xa2, 0xec, 0x1f, 0x87,
	0x8f, 0xdf, 0x9b, 0x3d, 0x86, 0x41, 0x56, 0x4b, 0xc6, 0x30, 0x58, 0x2b, 0xcc, 0x0d, 0x16, 0xb5,
	0xc9, 0x06, 0xb2, 0x73, 0x18, 0xbd, 0xc5, 0x3d, 0x1a, 0x3c, 0x6e, 0xeb, 0x09, 0x40, 0x33, 0xf6,
	0x32, 0x85, 0x43, 0xad, 0x4c, 0x0d, 0x9f, 0x3d, 0x84, 0x41, 0xfd, 0x43, 0xd0, 0x01, 0x84, 0x19,
	0x9a, 0xd9, 0x09, 0x05, 0x88, 0xfc, 0xd9, 0x19, 0x59, 0xfe, 0x24, 0xf5, 0xff, 0xe4, 0x1f, 0x02,
	0x7d, 0x0d, 0xd3, 0x6f, 0x36, 0xc0, 0x4e, 0xeb, 0xff, 0xe6, 0xeb, 0x77, 0x3e, 0x52, 0x72, 0xf6,
	0x7b, 0xd3, 0xc7, 0xcd, 0x4e, 0xe8, 0x1c, 0xc2, 0x2b, 0x34, 0x14, 0xec, 0xd8, 0x67, 0x9a, 0x8c,
	0xdb, 0x5a, 0x4b, 0xcf, 0xd0, 0x0d, 0x23, 0xeb, 0x30, 0xb2, 0x96, 0xf1, 0x14, 0x22, 0x6f, 0x9f,
	0xfe, 0x67, 0x07, 0x6d, 0x0c, 0xc9, 0xa4, 0x0b, 0x2d, 0x75, 0x15, 0xb9, 0x37, 0xfb, 0xe2, 0x57,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xee, 0xa5, 0x8b, 0xf4, 0xc9, 0x03, 0x00, 0x00,
}
