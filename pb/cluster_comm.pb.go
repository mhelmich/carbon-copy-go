// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cluster_comm.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// these are the only two raft operations possible
type RaftOps int32

const (
	RaftOps_Set    RaftOps = 0
	RaftOps_Delete RaftOps = 1
)

var RaftOps_name = map[int32]string{
	0: "Set",
	1: "Delete",
}
var RaftOps_value = map[string]int32{
	"Set":    0,
	"Delete": 1,
}

func (x RaftOps) String() string {
	return proto.EnumName(RaftOps_name, int32(x))
}
func (RaftOps) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type NodeInfo struct {
	// contains hostname and port
	Addr string `protobuf:"bytes,1,opt,name=addr" json:"addr,omitempty"`
	// the unique id of a node
	NodeId int32 `protobuf:"varint,2,opt,name=nodeId" json:"nodeId,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *NodeInfo) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *NodeInfo) GetNodeId() int32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

// the raft api enforces string as key and value type
type RaftCommand struct {
	Cmd   RaftOps `protobuf:"varint,1,opt,name=cmd,enum=pb.RaftOps" json:"cmd,omitempty"`
	Key   string  `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Value string  `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *RaftCommand) Reset()                    { *m = RaftCommand{} }
func (m *RaftCommand) String() string            { return proto.CompactTextString(m) }
func (*RaftCommand) ProtoMessage()               {}
func (*RaftCommand) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *RaftCommand) GetCmd() RaftOps {
	if m != nil {
		return m.Cmd
	}
	return RaftOps_Set
}

func (m *RaftCommand) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RaftCommand) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// I decided to cheap this out and make all of this a proto
type RaftSnapshot struct {
	Snap map[string]string `protobuf:"bytes,1,rep,name=snap" json:"snap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RaftSnapshot) Reset()                    { *m = RaftSnapshot{} }
func (m *RaftSnapshot) String() string            { return proto.CompactTextString(m) }
func (*RaftSnapshot) ProtoMessage()               {}
func (*RaftSnapshot) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *RaftSnapshot) GetSnap() map[string]string {
	if m != nil {
		return m.Snap
	}
	return nil
}

func init() {
	proto.RegisterType((*NodeInfo)(nil), "pb.NodeInfo")
	proto.RegisterType((*RaftCommand)(nil), "pb.RaftCommand")
	proto.RegisterType((*RaftSnapshot)(nil), "pb.RaftSnapshot")
	proto.RegisterEnum("pb.RaftOps", RaftOps_name, RaftOps_value)
}

func init() { proto.RegisterFile("cluster_comm.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 246 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x50, 0xcf, 0x4b, 0xc3, 0x30,
	0x18, 0x35, 0xcd, 0xd6, 0xd9, 0xaf, 0x22, 0xe5, 0x43, 0xa4, 0x0c, 0x94, 0xd2, 0x53, 0xf1, 0x90,
	0xc3, 0x04, 0x15, 0xaf, 0xea, 0xc1, 0x8b, 0x42, 0xe6, 0x5d, 0xd2, 0x26, 0x43, 0xb0, 0xf9, 0x41,
	0x9b, 0x29, 0xfb, 0xef, 0x25, 0x71, 0x15, 0x0f, 0xbb, 0xbd, 0x1f, 0x79, 0xef, 0x85, 0x0f, 0xb0,
	0xeb, 0xb7, 0xa3, 0x57, 0xc3, 0x7b, 0x67, 0xb5, 0x66, 0x6e, 0xb0, 0xde, 0x62, 0xe2, 0xda, 0xfa,
	0x06, 0x8e, 0x5f, 0xac, 0x54, 0xcf, 0x66, 0x63, 0x11, 0x61, 0x26, 0xa4, 0x1c, 0x4a, 0x52, 0x91,
	0x26, 0xe3, 0x11, 0xe3, 0x39, 0xa4, 0x26, 0xf8, 0xb2, 0x4c, 0x2a, 0xd2, 0xcc, 0xf9, 0x9e, 0xd5,
	0x6f, 0x90, 0x73, 0xb1, 0xf1, 0x0f, 0x56, 0x6b, 0x61, 0x24, 0x5e, 0x00, 0xed, 0xb4, 0x8c, 0xc9,
	0xd3, 0x55, 0xce, 0x5c, 0xcb, 0x82, 0xfb, 0xea, 0x46, 0x1e, 0x74, 0x2c, 0x80, 0x7e, 0xaa, 0x5d,
	0xac, 0xc8, 0x78, 0x80, 0x78, 0x06, 0xf3, 0x2f, 0xd1, 0x6f, 0x55, 0x49, 0xa3, 0xf6, 0x4b, 0xea,
	0x6f, 0x38, 0x09, 0xb9, 0xb5, 0x11, 0x6e, 0xfc, 0xb0, 0x1e, 0x19, 0xcc, 0x46, 0x23, 0x5c, 0x49,
	0x2a, 0xda, 0xe4, 0xab, 0xe5, 0xd4, 0x3b, 0xf9, 0x2c, 0x80, 0x27, 0xe3, 0x87, 0x1d, 0x8f, 0xef,
	0x96, 0xb7, 0x90, 0xfd, 0x49, 0xd3, 0x28, 0x39, 0x30, 0x9a, 0xfc, 0x1b, 0xbd, 0x4f, 0xee, 0xc8,
	0xd5, 0x25, 0x2c, 0xf6, 0x1f, 0xc6, 0x05, 0xd0, 0xb5, 0xf2, 0xc5, 0x11, 0x02, 0xa4, 0x8f, 0xaa,
	0x57, 0x5e, 0x15, 0xa4, 0x4d, 0xe3, 0xc5, 0xae, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xfb, 0xbb,
	0xb4, 0xdf, 0x47, 0x01, 0x00, 0x00,
}
